"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity
is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int

  """The hash of the parent block"""
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

enum Aggregation_interval {
  hour
  day
}

type Auction {
  id: ID!
  dao: DAO!
  startTime: BigInt!
  endTime: BigInt!
  extended: Boolean!
  highestBid: AuctionBid
  winningBid: AuctionBid
  firstBidTime: BigInt
  settled: Boolean!
  bidCount: Int!
  token: Token!
  bids(skip: Int = 0, first: Int = 100, orderBy: AuctionBid_orderBy, orderDirection: OrderDirection, where: AuctionBid_filter): [AuctionBid!]
}

input Auction_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  dao: String
  dao_not: String
  dao_gt: String
  dao_lt: String
  dao_gte: String
  dao_lte: String
  dao_in: [String!]
  dao_not_in: [String!]
  dao_contains: String
  dao_contains_nocase: String
  dao_not_contains: String
  dao_not_contains_nocase: String
  dao_starts_with: String
  dao_starts_with_nocase: String
  dao_not_starts_with: String
  dao_not_starts_with_nocase: String
  dao_ends_with: String
  dao_ends_with_nocase: String
  dao_not_ends_with: String
  dao_not_ends_with_nocase: String
  dao_: DAO_filter
  startTime: BigInt
  startTime_not: BigInt
  startTime_gt: BigInt
  startTime_lt: BigInt
  startTime_gte: BigInt
  startTime_lte: BigInt
  startTime_in: [BigInt!]
  startTime_not_in: [BigInt!]
  endTime: BigInt
  endTime_not: BigInt
  endTime_gt: BigInt
  endTime_lt: BigInt
  endTime_gte: BigInt
  endTime_lte: BigInt
  endTime_in: [BigInt!]
  endTime_not_in: [BigInt!]
  extended: Boolean
  extended_not: Boolean
  extended_in: [Boolean!]
  extended_not_in: [Boolean!]
  highestBid: String
  highestBid_not: String
  highestBid_gt: String
  highestBid_lt: String
  highestBid_gte: String
  highestBid_lte: String
  highestBid_in: [String!]
  highestBid_not_in: [String!]
  highestBid_contains: String
  highestBid_contains_nocase: String
  highestBid_not_contains: String
  highestBid_not_contains_nocase: String
  highestBid_starts_with: String
  highestBid_starts_with_nocase: String
  highestBid_not_starts_with: String
  highestBid_not_starts_with_nocase: String
  highestBid_ends_with: String
  highestBid_ends_with_nocase: String
  highestBid_not_ends_with: String
  highestBid_not_ends_with_nocase: String
  highestBid_: AuctionBid_filter
  winningBid: String
  winningBid_not: String
  winningBid_gt: String
  winningBid_lt: String
  winningBid_gte: String
  winningBid_lte: String
  winningBid_in: [String!]
  winningBid_not_in: [String!]
  winningBid_contains: String
  winningBid_contains_nocase: String
  winningBid_not_contains: String
  winningBid_not_contains_nocase: String
  winningBid_starts_with: String
  winningBid_starts_with_nocase: String
  winningBid_not_starts_with: String
  winningBid_not_starts_with_nocase: String
  winningBid_ends_with: String
  winningBid_ends_with_nocase: String
  winningBid_not_ends_with: String
  winningBid_not_ends_with_nocase: String
  winningBid_: AuctionBid_filter
  firstBidTime: BigInt
  firstBidTime_not: BigInt
  firstBidTime_gt: BigInt
  firstBidTime_lt: BigInt
  firstBidTime_gte: BigInt
  firstBidTime_lte: BigInt
  firstBidTime_in: [BigInt!]
  firstBidTime_not_in: [BigInt!]
  settled: Boolean
  settled_not: Boolean
  settled_in: [Boolean!]
  settled_not_in: [Boolean!]
  bidCount: Int
  bidCount_not: Int
  bidCount_gt: Int
  bidCount_lt: Int
  bidCount_gte: Int
  bidCount_lte: Int
  bidCount_in: [Int!]
  bidCount_not_in: [Int!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  bids_: AuctionBid_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Auction_filter]
  or: [Auction_filter]
}

enum Auction_orderBy {
  id
  dao
  dao__id
  dao__name
  dao__symbol
  dao__totalSupply
  dao__description
  dao__contractImage
  dao__projectURI
  dao__tokenAddress
  dao__metadataAddress
  dao__auctionAddress
  dao__treasuryAddress
  dao__governorAddress
  dao__ownerCount
  dao__proposalCount
  dao__totalAuctionSales
  startTime
  endTime
  extended
  highestBid
  highestBid__id
  highestBid__amount
  highestBid__bidder
  highestBid__bidTime
  winningBid
  winningBid__id
  winningBid__amount
  winningBid__bidder
  winningBid__bidTime
  firstBidTime
  settled
  bidCount
  token
  token__id
  token__name
  token__image
  token__content
  token__tokenContract
  token__tokenId
  token__owner
  token__mintedAt
  bids
}

type AuctionBid {
  id: ID!
  amount: BigInt!
  bidder: Bytes!
  auction: Auction!
  bidTime: BigInt!
}

input AuctionBid_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  bidder: Bytes
  bidder_not: Bytes
  bidder_gt: Bytes
  bidder_lt: Bytes
  bidder_gte: Bytes
  bidder_lte: Bytes
  bidder_in: [Bytes!]
  bidder_not_in: [Bytes!]
  bidder_contains: Bytes
  bidder_not_contains: Bytes
  auction: String
  auction_not: String
  auction_gt: String
  auction_lt: String
  auction_gte: String
  auction_lte: String
  auction_in: [String!]
  auction_not_in: [String!]
  auction_contains: String
  auction_contains_nocase: String
  auction_not_contains: String
  auction_not_contains_nocase: String
  auction_starts_with: String
  auction_starts_with_nocase: String
  auction_not_starts_with: String
  auction_not_starts_with_nocase: String
  auction_ends_with: String
  auction_ends_with_nocase: String
  auction_not_ends_with: String
  auction_not_ends_with_nocase: String
  auction_: Auction_filter
  bidTime: BigInt
  bidTime_not: BigInt
  bidTime_gt: BigInt
  bidTime_lt: BigInt
  bidTime_gte: BigInt
  bidTime_lte: BigInt
  bidTime_in: [BigInt!]
  bidTime_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AuctionBid_filter]
  or: [AuctionBid_filter]
}

enum AuctionBid_orderBy {
  id
  amount
  bidder
  auction
  auction__id
  auction__startTime
  auction__endTime
  auction__extended
  auction__firstBidTime
  auction__settled
  auction__bidCount
  bidTime
}

type AuctionConfig {
  id: ID!
  duration: BigInt!
  reservePrice: BigInt!
  timeBuffer: BigInt!
  minimumBidIncrement: BigInt!
}

input AuctionConfig_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  duration: BigInt
  duration_not: BigInt
  duration_gt: BigInt
  duration_lt: BigInt
  duration_gte: BigInt
  duration_lte: BigInt
  duration_in: [BigInt!]
  duration_not_in: [BigInt!]
  reservePrice: BigInt
  reservePrice_not: BigInt
  reservePrice_gt: BigInt
  reservePrice_lt: BigInt
  reservePrice_gte: BigInt
  reservePrice_lte: BigInt
  reservePrice_in: [BigInt!]
  reservePrice_not_in: [BigInt!]
  timeBuffer: BigInt
  timeBuffer_not: BigInt
  timeBuffer_gt: BigInt
  timeBuffer_lt: BigInt
  timeBuffer_gte: BigInt
  timeBuffer_lte: BigInt
  timeBuffer_in: [BigInt!]
  timeBuffer_not_in: [BigInt!]
  minimumBidIncrement: BigInt
  minimumBidIncrement_not: BigInt
  minimumBidIncrement_gt: BigInt
  minimumBidIncrement_lt: BigInt
  minimumBidIncrement_gte: BigInt
  minimumBidIncrement_lte: BigInt
  minimumBidIncrement_in: [BigInt!]
  minimumBidIncrement_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AuctionConfig_filter]
  or: [AuctionConfig_filter]
}

enum AuctionConfig_orderBy {
  id
  duration
  reservePrice
  timeBuffer
  minimumBidIncrement
}

scalar BigDecimal

scalar BigInt

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

input BlockChangedFilter {
  number_gte: Int!
}

scalar Bytes

type DAO {
  id: ID!
  name: String!
  symbol: String!
  totalSupply: Int!
  description: String!
  contractImage: String!
  projectURI: String!
  tokenAddress: Bytes!
  metadataAddress: Bytes!
  auctionAddress: Bytes!
  treasuryAddress: Bytes!
  governorAddress: Bytes!
  ownerCount: Int!
  proposalCount: Int!
  totalAuctionSales: BigInt!
  auctionConfig: AuctionConfig!
  currentAuction: Auction
  metadataProperties(skip: Int = 0, first: Int = 100, orderBy: MetadataProperty_orderBy, orderDirection: OrderDirection, where: MetadataProperty_filter): [MetadataProperty!]
  owners(skip: Int = 0, first: Int = 100, orderBy: DAOTokenOwner_orderBy, orderDirection: OrderDirection, where: DAOTokenOwner_filter): [DAOTokenOwner!]!
  tokens(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
  proposals(skip: Int = 0, first: Int = 100, orderBy: Proposal_orderBy, orderDirection: OrderDirection, where: Proposal_filter): [Proposal!]!
  auctions(skip: Int = 0, first: Int = 100, orderBy: Auction_orderBy, orderDirection: OrderDirection, where: Auction_filter): [Auction!]!
}

input DAO_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: Int
  totalSupply_not: Int
  totalSupply_gt: Int
  totalSupply_lt: Int
  totalSupply_gte: Int
  totalSupply_lte: Int
  totalSupply_in: [Int!]
  totalSupply_not_in: [Int!]
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  contractImage: String
  contractImage_not: String
  contractImage_gt: String
  contractImage_lt: String
  contractImage_gte: String
  contractImage_lte: String
  contractImage_in: [String!]
  contractImage_not_in: [String!]
  contractImage_contains: String
  contractImage_contains_nocase: String
  contractImage_not_contains: String
  contractImage_not_contains_nocase: String
  contractImage_starts_with: String
  contractImage_starts_with_nocase: String
  contractImage_not_starts_with: String
  contractImage_not_starts_with_nocase: String
  contractImage_ends_with: String
  contractImage_ends_with_nocase: String
  contractImage_not_ends_with: String
  contractImage_not_ends_with_nocase: String
  projectURI: String
  projectURI_not: String
  projectURI_gt: String
  projectURI_lt: String
  projectURI_gte: String
  projectURI_lte: String
  projectURI_in: [String!]
  projectURI_not_in: [String!]
  projectURI_contains: String
  projectURI_contains_nocase: String
  projectURI_not_contains: String
  projectURI_not_contains_nocase: String
  projectURI_starts_with: String
  projectURI_starts_with_nocase: String
  projectURI_not_starts_with: String
  projectURI_not_starts_with_nocase: String
  projectURI_ends_with: String
  projectURI_ends_with_nocase: String
  projectURI_not_ends_with: String
  projectURI_not_ends_with_nocase: String
  tokenAddress: Bytes
  tokenAddress_not: Bytes
  tokenAddress_gt: Bytes
  tokenAddress_lt: Bytes
  tokenAddress_gte: Bytes
  tokenAddress_lte: Bytes
  tokenAddress_in: [Bytes!]
  tokenAddress_not_in: [Bytes!]
  tokenAddress_contains: Bytes
  tokenAddress_not_contains: Bytes
  metadataAddress: Bytes
  metadataAddress_not: Bytes
  metadataAddress_gt: Bytes
  metadataAddress_lt: Bytes
  metadataAddress_gte: Bytes
  metadataAddress_lte: Bytes
  metadataAddress_in: [Bytes!]
  metadataAddress_not_in: [Bytes!]
  metadataAddress_contains: Bytes
  metadataAddress_not_contains: Bytes
  auctionAddress: Bytes
  auctionAddress_not: Bytes
  auctionAddress_gt: Bytes
  auctionAddress_lt: Bytes
  auctionAddress_gte: Bytes
  auctionAddress_lte: Bytes
  auctionAddress_in: [Bytes!]
  auctionAddress_not_in: [Bytes!]
  auctionAddress_contains: Bytes
  auctionAddress_not_contains: Bytes
  treasuryAddress: Bytes
  treasuryAddress_not: Bytes
  treasuryAddress_gt: Bytes
  treasuryAddress_lt: Bytes
  treasuryAddress_gte: Bytes
  treasuryAddress_lte: Bytes
  treasuryAddress_in: [Bytes!]
  treasuryAddress_not_in: [Bytes!]
  treasuryAddress_contains: Bytes
  treasuryAddress_not_contains: Bytes
  governorAddress: Bytes
  governorAddress_not: Bytes
  governorAddress_gt: Bytes
  governorAddress_lt: Bytes
  governorAddress_gte: Bytes
  governorAddress_lte: Bytes
  governorAddress_in: [Bytes!]
  governorAddress_not_in: [Bytes!]
  governorAddress_contains: Bytes
  governorAddress_not_contains: Bytes
  ownerCount: Int
  ownerCount_not: Int
  ownerCount_gt: Int
  ownerCount_lt: Int
  ownerCount_gte: Int
  ownerCount_lte: Int
  ownerCount_in: [Int!]
  ownerCount_not_in: [Int!]
  proposalCount: Int
  proposalCount_not: Int
  proposalCount_gt: Int
  proposalCount_lt: Int
  proposalCount_gte: Int
  proposalCount_lte: Int
  proposalCount_in: [Int!]
  proposalCount_not_in: [Int!]
  totalAuctionSales: BigInt
  totalAuctionSales_not: BigInt
  totalAuctionSales_gt: BigInt
  totalAuctionSales_lt: BigInt
  totalAuctionSales_gte: BigInt
  totalAuctionSales_lte: BigInt
  totalAuctionSales_in: [BigInt!]
  totalAuctionSales_not_in: [BigInt!]
  auctionConfig: String
  auctionConfig_not: String
  auctionConfig_gt: String
  auctionConfig_lt: String
  auctionConfig_gte: String
  auctionConfig_lte: String
  auctionConfig_in: [String!]
  auctionConfig_not_in: [String!]
  auctionConfig_contains: String
  auctionConfig_contains_nocase: String
  auctionConfig_not_contains: String
  auctionConfig_not_contains_nocase: String
  auctionConfig_starts_with: String
  auctionConfig_starts_with_nocase: String
  auctionConfig_not_starts_with: String
  auctionConfig_not_starts_with_nocase: String
  auctionConfig_ends_with: String
  auctionConfig_ends_with_nocase: String
  auctionConfig_not_ends_with: String
  auctionConfig_not_ends_with_nocase: String
  auctionConfig_: AuctionConfig_filter
  currentAuction: String
  currentAuction_not: String
  currentAuction_gt: String
  currentAuction_lt: String
  currentAuction_gte: String
  currentAuction_lte: String
  currentAuction_in: [String!]
  currentAuction_not_in: [String!]
  currentAuction_contains: String
  currentAuction_contains_nocase: String
  currentAuction_not_contains: String
  currentAuction_not_contains_nocase: String
  currentAuction_starts_with: String
  currentAuction_starts_with_nocase: String
  currentAuction_not_starts_with: String
  currentAuction_not_starts_with_nocase: String
  currentAuction_ends_with: String
  currentAuction_ends_with_nocase: String
  currentAuction_not_ends_with: String
  currentAuction_not_ends_with_nocase: String
  currentAuction_: Auction_filter
  metadataProperties: [String!]
  metadataProperties_not: [String!]
  metadataProperties_contains: [String!]
  metadataProperties_contains_nocase: [String!]
  metadataProperties_not_contains: [String!]
  metadataProperties_not_contains_nocase: [String!]
  metadataProperties_: MetadataProperty_filter
  owners_: DAOTokenOwner_filter
  tokens_: Token_filter
  proposals_: Proposal_filter
  auctions_: Auction_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DAO_filter]
  or: [DAO_filter]
}

enum DAO_orderBy {
  id
  name
  symbol
  totalSupply
  description
  contractImage
  projectURI
  tokenAddress
  metadataAddress
  auctionAddress
  treasuryAddress
  governorAddress
  ownerCount
  proposalCount
  totalAuctionSales
  auctionConfig
  auctionConfig__id
  auctionConfig__duration
  auctionConfig__reservePrice
  auctionConfig__timeBuffer
  auctionConfig__minimumBidIncrement
  currentAuction
  currentAuction__id
  currentAuction__startTime
  currentAuction__endTime
  currentAuction__extended
  currentAuction__firstBidTime
  currentAuction__settled
  currentAuction__bidCount
  metadataProperties
  owners
  tokens
  proposals
  auctions
}

type DAOTokenOwner {
  id: ID!
  owner: Bytes!
  dao: DAO!
  daoTokenCount: Int!
  daoTokens(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
}

input DAOTokenOwner_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  dao: String
  dao_not: String
  dao_gt: String
  dao_lt: String
  dao_gte: String
  dao_lte: String
  dao_in: [String!]
  dao_not_in: [String!]
  dao_contains: String
  dao_contains_nocase: String
  dao_not_contains: String
  dao_not_contains_nocase: String
  dao_starts_with: String
  dao_starts_with_nocase: String
  dao_not_starts_with: String
  dao_not_starts_with_nocase: String
  dao_ends_with: String
  dao_ends_with_nocase: String
  dao_not_ends_with: String
  dao_not_ends_with_nocase: String
  dao_: DAO_filter
  daoTokenCount: Int
  daoTokenCount_not: Int
  daoTokenCount_gt: Int
  daoTokenCount_lt: Int
  daoTokenCount_gte: Int
  daoTokenCount_lte: Int
  daoTokenCount_in: [Int!]
  daoTokenCount_not_in: [Int!]
  daoTokens_: Token_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DAOTokenOwner_filter]
  or: [DAOTokenOwner_filter]
}

enum DAOTokenOwner_orderBy {
  id
  owner
  dao
  dao__id
  dao__name
  dao__symbol
  dao__totalSupply
  dao__description
  dao__contractImage
  dao__projectURI
  dao__tokenAddress
  dao__metadataAddress
  dao__auctionAddress
  dao__treasuryAddress
  dao__governorAddress
  dao__ownerCount
  dao__proposalCount
  dao__totalAuctionSales
  daoTokenCount
  daoTokens
}

"""
8 bytes signed integer

"""
scalar Int8

type MetadataItem {
  id: ID!
  index: Int!
  propertyInfo: MetadataProperty!
  propertyId: BigInt!
  name: String!
  isNewProperty: Boolean!
}

input MetadataItem_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  index: Int
  index_not: Int
  index_gt: Int
  index_lt: Int
  index_gte: Int
  index_lte: Int
  index_in: [Int!]
  index_not_in: [Int!]
  propertyInfo: String
  propertyInfo_not: String
  propertyInfo_gt: String
  propertyInfo_lt: String
  propertyInfo_gte: String
  propertyInfo_lte: String
  propertyInfo_in: [String!]
  propertyInfo_not_in: [String!]
  propertyInfo_contains: String
  propertyInfo_contains_nocase: String
  propertyInfo_not_contains: String
  propertyInfo_not_contains_nocase: String
  propertyInfo_starts_with: String
  propertyInfo_starts_with_nocase: String
  propertyInfo_not_starts_with: String
  propertyInfo_not_starts_with_nocase: String
  propertyInfo_ends_with: String
  propertyInfo_ends_with_nocase: String
  propertyInfo_not_ends_with: String
  propertyInfo_not_ends_with_nocase: String
  propertyInfo_: MetadataProperty_filter
  propertyId: BigInt
  propertyId_not: BigInt
  propertyId_gt: BigInt
  propertyId_lt: BigInt
  propertyId_gte: BigInt
  propertyId_lte: BigInt
  propertyId_in: [BigInt!]
  propertyId_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  isNewProperty: Boolean
  isNewProperty_not: Boolean
  isNewProperty_in: [Boolean!]
  isNewProperty_not_in: [Boolean!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MetadataItem_filter]
  or: [MetadataItem_filter]
}

enum MetadataItem_orderBy {
  id
  index
  propertyInfo
  propertyInfo__id
  propertyInfo__ipfsBaseUri
  propertyInfo__ipfsExtension
  propertyInfo__createdAt
  propertyInfo__deleted
  propertyId
  name
  isNewProperty
}

type MetadataProperty {
  id: ID!
  dao: DAO!
  names: [String!]!
  items(skip: Int = 0, first: Int = 100, orderBy: MetadataItem_orderBy, orderDirection: OrderDirection, where: MetadataItem_filter): [MetadataItem!]!
  ipfsBaseUri: String!
  ipfsExtension: String!
  createdAt: BigInt!
  deleted: Boolean!
}

input MetadataProperty_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  dao: String
  dao_not: String
  dao_gt: String
  dao_lt: String
  dao_gte: String
  dao_lte: String
  dao_in: [String!]
  dao_not_in: [String!]
  dao_contains: String
  dao_contains_nocase: String
  dao_not_contains: String
  dao_not_contains_nocase: String
  dao_starts_with: String
  dao_starts_with_nocase: String
  dao_not_starts_with: String
  dao_not_starts_with_nocase: String
  dao_ends_with: String
  dao_ends_with_nocase: String
  dao_not_ends_with: String
  dao_not_ends_with_nocase: String
  dao_: DAO_filter
  names: [String!]
  names_not: [String!]
  names_contains: [String!]
  names_contains_nocase: [String!]
  names_not_contains: [String!]
  names_not_contains_nocase: [String!]
  items_: MetadataItem_filter
  ipfsBaseUri: String
  ipfsBaseUri_not: String
  ipfsBaseUri_gt: String
  ipfsBaseUri_lt: String
  ipfsBaseUri_gte: String
  ipfsBaseUri_lte: String
  ipfsBaseUri_in: [String!]
  ipfsBaseUri_not_in: [String!]
  ipfsBaseUri_contains: String
  ipfsBaseUri_contains_nocase: String
  ipfsBaseUri_not_contains: String
  ipfsBaseUri_not_contains_nocase: String
  ipfsBaseUri_starts_with: String
  ipfsBaseUri_starts_with_nocase: String
  ipfsBaseUri_not_starts_with: String
  ipfsBaseUri_not_starts_with_nocase: String
  ipfsBaseUri_ends_with: String
  ipfsBaseUri_ends_with_nocase: String
  ipfsBaseUri_not_ends_with: String
  ipfsBaseUri_not_ends_with_nocase: String
  ipfsExtension: String
  ipfsExtension_not: String
  ipfsExtension_gt: String
  ipfsExtension_lt: String
  ipfsExtension_gte: String
  ipfsExtension_lte: String
  ipfsExtension_in: [String!]
  ipfsExtension_not_in: [String!]
  ipfsExtension_contains: String
  ipfsExtension_contains_nocase: String
  ipfsExtension_not_contains: String
  ipfsExtension_not_contains_nocase: String
  ipfsExtension_starts_with: String
  ipfsExtension_starts_with_nocase: String
  ipfsExtension_not_starts_with: String
  ipfsExtension_not_starts_with_nocase: String
  ipfsExtension_ends_with: String
  ipfsExtension_ends_with_nocase: String
  ipfsExtension_not_ends_with: String
  ipfsExtension_not_ends_with_nocase: String
  createdAt: BigInt
  createdAt_not: BigInt
  createdAt_gt: BigInt
  createdAt_lt: BigInt
  createdAt_gte: BigInt
  createdAt_lte: BigInt
  createdAt_in: [BigInt!]
  createdAt_not_in: [BigInt!]
  deleted: Boolean
  deleted_not: Boolean
  deleted_in: [Boolean!]
  deleted_not_in: [Boolean!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MetadataProperty_filter]
  or: [MetadataProperty_filter]
}

enum MetadataProperty_orderBy {
  id
  dao
  dao__id
  dao__name
  dao__symbol
  dao__totalSupply
  dao__description
  dao__contractImage
  dao__projectURI
  dao__tokenAddress
  dao__metadataAddress
  dao__auctionAddress
  dao__treasuryAddress
  dao__governorAddress
  dao__ownerCount
  dao__proposalCount
  dao__totalAuctionSales
  names
  items
  ipfsBaseUri
  ipfsExtension
  createdAt
  deleted
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Proposal {
  id: ID!
  proposalId: Bytes!
  proposalNumber: Int!
  dao: DAO!
  targets: [Bytes!]!
  values: [BigInt!]!
  calldatas: String
  title: String
  description: String
  descriptionHash: Bytes!
  proposer: Bytes!
  timeCreated: BigInt!
  executableFrom: BigInt
  expiresAt: BigInt
  againstVotes: Int!
  forVotes: Int!
  abstainVotes: Int!
  voteStart: BigInt!
  voteEnd: BigInt!
  proposalThreshold: BigInt!
  quorumVotes: BigInt!
  queued: Boolean!
  executed: Boolean!
  canceled: Boolean!
  vetoed: Boolean!
  voteCount: Int!
  snapshotBlockNumber: BigInt!
  transactionHash: Bytes!
  votes(skip: Int = 0, first: Int = 100, orderBy: ProposalVote_orderBy, orderDirection: OrderDirection, where: ProposalVote_filter): [ProposalVote!]!
}

input Proposal_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  proposalId: Bytes
  proposalId_not: Bytes
  proposalId_gt: Bytes
  proposalId_lt: Bytes
  proposalId_gte: Bytes
  proposalId_lte: Bytes
  proposalId_in: [Bytes!]
  proposalId_not_in: [Bytes!]
  proposalId_contains: Bytes
  proposalId_not_contains: Bytes
  proposalNumber: Int
  proposalNumber_not: Int
  proposalNumber_gt: Int
  proposalNumber_lt: Int
  proposalNumber_gte: Int
  proposalNumber_lte: Int
  proposalNumber_in: [Int!]
  proposalNumber_not_in: [Int!]
  dao: String
  dao_not: String
  dao_gt: String
  dao_lt: String
  dao_gte: String
  dao_lte: String
  dao_in: [String!]
  dao_not_in: [String!]
  dao_contains: String
  dao_contains_nocase: String
  dao_not_contains: String
  dao_not_contains_nocase: String
  dao_starts_with: String
  dao_starts_with_nocase: String
  dao_not_starts_with: String
  dao_not_starts_with_nocase: String
  dao_ends_with: String
  dao_ends_with_nocase: String
  dao_not_ends_with: String
  dao_not_ends_with_nocase: String
  dao_: DAO_filter
  targets: [Bytes!]
  targets_not: [Bytes!]
  targets_contains: [Bytes!]
  targets_contains_nocase: [Bytes!]
  targets_not_contains: [Bytes!]
  targets_not_contains_nocase: [Bytes!]
  values: [BigInt!]
  values_not: [BigInt!]
  values_contains: [BigInt!]
  values_contains_nocase: [BigInt!]
  values_not_contains: [BigInt!]
  values_not_contains_nocase: [BigInt!]
  calldatas: String
  calldatas_not: String
  calldatas_gt: String
  calldatas_lt: String
  calldatas_gte: String
  calldatas_lte: String
  calldatas_in: [String!]
  calldatas_not_in: [String!]
  calldatas_contains: String
  calldatas_contains_nocase: String
  calldatas_not_contains: String
  calldatas_not_contains_nocase: String
  calldatas_starts_with: String
  calldatas_starts_with_nocase: String
  calldatas_not_starts_with: String
  calldatas_not_starts_with_nocase: String
  calldatas_ends_with: String
  calldatas_ends_with_nocase: String
  calldatas_not_ends_with: String
  calldatas_not_ends_with_nocase: String
  title: String
  title_not: String
  title_gt: String
  title_lt: String
  title_gte: String
  title_lte: String
  title_in: [String!]
  title_not_in: [String!]
  title_contains: String
  title_contains_nocase: String
  title_not_contains: String
  title_not_contains_nocase: String
  title_starts_with: String
  title_starts_with_nocase: String
  title_not_starts_with: String
  title_not_starts_with_nocase: String
  title_ends_with: String
  title_ends_with_nocase: String
  title_not_ends_with: String
  title_not_ends_with_nocase: String
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  descriptionHash: Bytes
  descriptionHash_not: Bytes
  descriptionHash_gt: Bytes
  descriptionHash_lt: Bytes
  descriptionHash_gte: Bytes
  descriptionHash_lte: Bytes
  descriptionHash_in: [Bytes!]
  descriptionHash_not_in: [Bytes!]
  descriptionHash_contains: Bytes
  descriptionHash_not_contains: Bytes
  proposer: Bytes
  proposer_not: Bytes
  proposer_gt: Bytes
  proposer_lt: Bytes
  proposer_gte: Bytes
  proposer_lte: Bytes
  proposer_in: [Bytes!]
  proposer_not_in: [Bytes!]
  proposer_contains: Bytes
  proposer_not_contains: Bytes
  timeCreated: BigInt
  timeCreated_not: BigInt
  timeCreated_gt: BigInt
  timeCreated_lt: BigInt
  timeCreated_gte: BigInt
  timeCreated_lte: BigInt
  timeCreated_in: [BigInt!]
  timeCreated_not_in: [BigInt!]
  executableFrom: BigInt
  executableFrom_not: BigInt
  executableFrom_gt: BigInt
  executableFrom_lt: BigInt
  executableFrom_gte: BigInt
  executableFrom_lte: BigInt
  executableFrom_in: [BigInt!]
  executableFrom_not_in: [BigInt!]
  expiresAt: BigInt
  expiresAt_not: BigInt
  expiresAt_gt: BigInt
  expiresAt_lt: BigInt
  expiresAt_gte: BigInt
  expiresAt_lte: BigInt
  expiresAt_in: [BigInt!]
  expiresAt_not_in: [BigInt!]
  againstVotes: Int
  againstVotes_not: Int
  againstVotes_gt: Int
  againstVotes_lt: Int
  againstVotes_gte: Int
  againstVotes_lte: Int
  againstVotes_in: [Int!]
  againstVotes_not_in: [Int!]
  forVotes: Int
  forVotes_not: Int
  forVotes_gt: Int
  forVotes_lt: Int
  forVotes_gte: Int
  forVotes_lte: Int
  forVotes_in: [Int!]
  forVotes_not_in: [Int!]
  abstainVotes: Int
  abstainVotes_not: Int
  abstainVotes_gt: Int
  abstainVotes_lt: Int
  abstainVotes_gte: Int
  abstainVotes_lte: Int
  abstainVotes_in: [Int!]
  abstainVotes_not_in: [Int!]
  voteStart: BigInt
  voteStart_not: BigInt
  voteStart_gt: BigInt
  voteStart_lt: BigInt
  voteStart_gte: BigInt
  voteStart_lte: BigInt
  voteStart_in: [BigInt!]
  voteStart_not_in: [BigInt!]
  voteEnd: BigInt
  voteEnd_not: BigInt
  voteEnd_gt: BigInt
  voteEnd_lt: BigInt
  voteEnd_gte: BigInt
  voteEnd_lte: BigInt
  voteEnd_in: [BigInt!]
  voteEnd_not_in: [BigInt!]
  proposalThreshold: BigInt
  proposalThreshold_not: BigInt
  proposalThreshold_gt: BigInt
  proposalThreshold_lt: BigInt
  proposalThreshold_gte: BigInt
  proposalThreshold_lte: BigInt
  proposalThreshold_in: [BigInt!]
  proposalThreshold_not_in: [BigInt!]
  quorumVotes: BigInt
  quorumVotes_not: BigInt
  quorumVotes_gt: BigInt
  quorumVotes_lt: BigInt
  quorumVotes_gte: BigInt
  quorumVotes_lte: BigInt
  quorumVotes_in: [BigInt!]
  quorumVotes_not_in: [BigInt!]
  queued: Boolean
  queued_not: Boolean
  queued_in: [Boolean!]
  queued_not_in: [Boolean!]
  executed: Boolean
  executed_not: Boolean
  executed_in: [Boolean!]
  executed_not_in: [Boolean!]
  canceled: Boolean
  canceled_not: Boolean
  canceled_in: [Boolean!]
  canceled_not_in: [Boolean!]
  vetoed: Boolean
  vetoed_not: Boolean
  vetoed_in: [Boolean!]
  vetoed_not_in: [Boolean!]
  voteCount: Int
  voteCount_not: Int
  voteCount_gt: Int
  voteCount_lt: Int
  voteCount_gte: Int
  voteCount_lte: Int
  voteCount_in: [Int!]
  voteCount_not_in: [Int!]
  snapshotBlockNumber: BigInt
  snapshotBlockNumber_not: BigInt
  snapshotBlockNumber_gt: BigInt
  snapshotBlockNumber_lt: BigInt
  snapshotBlockNumber_gte: BigInt
  snapshotBlockNumber_lte: BigInt
  snapshotBlockNumber_in: [BigInt!]
  snapshotBlockNumber_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  votes_: ProposalVote_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Proposal_filter]
  or: [Proposal_filter]
}

enum Proposal_orderBy {
  id
  proposalId
  proposalNumber
  dao
  dao__id
  dao__name
  dao__symbol
  dao__totalSupply
  dao__description
  dao__contractImage
  dao__projectURI
  dao__tokenAddress
  dao__metadataAddress
  dao__auctionAddress
  dao__treasuryAddress
  dao__governorAddress
  dao__ownerCount
  dao__proposalCount
  dao__totalAuctionSales
  targets
  values
  calldatas
  title
  description
  descriptionHash
  proposer
  timeCreated
  executableFrom
  expiresAt
  againstVotes
  forVotes
  abstainVotes
  voteStart
  voteEnd
  proposalThreshold
  quorumVotes
  queued
  executed
  canceled
  vetoed
  voteCount
  snapshotBlockNumber
  transactionHash
  votes
}

type ProposalVote {
  id: ID!
  voter: Bytes!
  support: ProposalVoteSupport!
  weight: Int!
  reason: String
  proposal: Proposal!
}

input ProposalVote_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  voter: Bytes
  voter_not: Bytes
  voter_gt: Bytes
  voter_lt: Bytes
  voter_gte: Bytes
  voter_lte: Bytes
  voter_in: [Bytes!]
  voter_not_in: [Bytes!]
  voter_contains: Bytes
  voter_not_contains: Bytes
  support: ProposalVoteSupport
  support_not: ProposalVoteSupport
  support_in: [ProposalVoteSupport!]
  support_not_in: [ProposalVoteSupport!]
  weight: Int
  weight_not: Int
  weight_gt: Int
  weight_lt: Int
  weight_gte: Int
  weight_lte: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  reason: String
  reason_not: String
  reason_gt: String
  reason_lt: String
  reason_gte: String
  reason_lte: String
  reason_in: [String!]
  reason_not_in: [String!]
  reason_contains: String
  reason_contains_nocase: String
  reason_not_contains: String
  reason_not_contains_nocase: String
  reason_starts_with: String
  reason_starts_with_nocase: String
  reason_not_starts_with: String
  reason_not_starts_with_nocase: String
  reason_ends_with: String
  reason_ends_with_nocase: String
  reason_not_ends_with: String
  reason_not_ends_with_nocase: String
  proposal: String
  proposal_not: String
  proposal_gt: String
  proposal_lt: String
  proposal_gte: String
  proposal_lte: String
  proposal_in: [String!]
  proposal_not_in: [String!]
  proposal_contains: String
  proposal_contains_nocase: String
  proposal_not_contains: String
  proposal_not_contains_nocase: String
  proposal_starts_with: String
  proposal_starts_with_nocase: String
  proposal_not_starts_with: String
  proposal_not_starts_with_nocase: String
  proposal_ends_with: String
  proposal_ends_with_nocase: String
  proposal_not_ends_with: String
  proposal_not_ends_with_nocase: String
  proposal_: Proposal_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ProposalVote_filter]
  or: [ProposalVote_filter]
}

enum ProposalVote_orderBy {
  id
  voter
  support
  weight
  reason
  proposal
  proposal__id
  proposal__proposalId
  proposal__proposalNumber
  proposal__calldatas
  proposal__title
  proposal__description
  proposal__descriptionHash
  proposal__proposer
  proposal__timeCreated
  proposal__executableFrom
  proposal__expiresAt
  proposal__againstVotes
  proposal__forVotes
  proposal__abstainVotes
  proposal__voteStart
  proposal__voteEnd
  proposal__proposalThreshold
  proposal__quorumVotes
  proposal__queued
  proposal__executed
  proposal__canceled
  proposal__vetoed
  proposal__voteCount
  proposal__snapshotBlockNumber
  proposal__transactionHash
}

enum ProposalVoteSupport {
  FOR
  AGAINST
  ABSTAIN
}

type Query {
  dao(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAO
  daos(
    skip: Int = 0
    first: Int = 100
    orderBy: DAO_orderBy
    orderDirection: OrderDirection
    where: DAO_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAO!]!
  daotokenOwner(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAOTokenOwner
  daotokenOwners(
    skip: Int = 0
    first: Int = 100
    orderBy: DAOTokenOwner_orderBy
    orderDirection: OrderDirection
    where: DAOTokenOwner_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAOTokenOwner!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  proposal(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    skip: Int = 0
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    where: Proposal_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposal!]!
  proposalVote(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProposalVote
  proposalVotes(
    skip: Int = 0
    first: Int = 100
    orderBy: ProposalVote_orderBy
    orderDirection: OrderDirection
    where: ProposalVote_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProposalVote!]!
  auctionConfig(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuctionConfig
  auctionConfigs(
    skip: Int = 0
    first: Int = 100
    orderBy: AuctionConfig_orderBy
    orderDirection: OrderDirection
    where: AuctionConfig_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuctionConfig!]!
  auction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Auction
  auctions(
    skip: Int = 0
    first: Int = 100
    orderBy: Auction_orderBy
    orderDirection: OrderDirection
    where: Auction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Auction!]!
  auctionBid(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuctionBid
  auctionBids(
    skip: Int = 0
    first: Int = 100
    orderBy: AuctionBid_orderBy
    orderDirection: OrderDirection
    where: AuctionBid_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuctionBid!]!
  metadataProperty(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MetadataProperty
  metadataProperties(
    skip: Int = 0
    first: Int = 100
    orderBy: MetadataProperty_orderBy
    orderDirection: OrderDirection
    where: MetadataProperty_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MetadataProperty!]!
  metadataItem(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MetadataItem
  metadataItems(
    skip: Int = 0
    first: Int = 100
    orderBy: MetadataItem_orderBy
    orderDirection: OrderDirection
    where: MetadataItem_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MetadataItem!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  dao(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAO
  daos(
    skip: Int = 0
    first: Int = 100
    orderBy: DAO_orderBy
    orderDirection: OrderDirection
    where: DAO_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAO!]!
  daotokenOwner(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAOTokenOwner
  daotokenOwners(
    skip: Int = 0
    first: Int = 100
    orderBy: DAOTokenOwner_orderBy
    orderDirection: OrderDirection
    where: DAOTokenOwner_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAOTokenOwner!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  proposal(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    skip: Int = 0
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    where: Proposal_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposal!]!
  proposalVote(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProposalVote
  proposalVotes(
    skip: Int = 0
    first: Int = 100
    orderBy: ProposalVote_orderBy
    orderDirection: OrderDirection
    where: ProposalVote_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProposalVote!]!
  auctionConfig(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuctionConfig
  auctionConfigs(
    skip: Int = 0
    first: Int = 100
    orderBy: AuctionConfig_orderBy
    orderDirection: OrderDirection
    where: AuctionConfig_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuctionConfig!]!
  auction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Auction
  auctions(
    skip: Int = 0
    first: Int = 100
    orderBy: Auction_orderBy
    orderDirection: OrderDirection
    where: Auction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Auction!]!
  auctionBid(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuctionBid
  auctionBids(
    skip: Int = 0
    first: Int = 100
    orderBy: AuctionBid_orderBy
    orderDirection: OrderDirection
    where: AuctionBid_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuctionBid!]!
  metadataProperty(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MetadataProperty
  metadataProperties(
    skip: Int = 0
    first: Int = 100
    orderBy: MetadataProperty_orderBy
    orderDirection: OrderDirection
    where: MetadataProperty_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MetadataProperty!]!
  metadataItem(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MetadataItem
  metadataItems(
    skip: Int = 0
    first: Int = 100
    orderBy: MetadataItem_orderBy
    orderDirection: OrderDirection
    where: MetadataItem_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MetadataItem!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type Token {
  id: ID!
  name: String!
  image: String
  content: String
  tokenContract: Bytes!
  tokenId: BigInt!
  owner: Bytes!
  ownerInfo: DAOTokenOwner!
  mintedAt: BigInt!
  dao: DAO!
  auction: Auction
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  image: String
  image_not: String
  image_gt: String
  image_lt: String
  image_gte: String
  image_lte: String
  image_in: [String!]
  image_not_in: [String!]
  image_contains: String
  image_contains_nocase: String
  image_not_contains: String
  image_not_contains_nocase: String
  image_starts_with: String
  image_starts_with_nocase: String
  image_not_starts_with: String
  image_not_starts_with_nocase: String
  image_ends_with: String
  image_ends_with_nocase: String
  image_not_ends_with: String
  image_not_ends_with_nocase: String
  content: String
  content_not: String
  content_gt: String
  content_lt: String
  content_gte: String
  content_lte: String
  content_in: [String!]
  content_not_in: [String!]
  content_contains: String
  content_contains_nocase: String
  content_not_contains: String
  content_not_contains_nocase: String
  content_starts_with: String
  content_starts_with_nocase: String
  content_not_starts_with: String
  content_not_starts_with_nocase: String
  content_ends_with: String
  content_ends_with_nocase: String
  content_not_ends_with: String
  content_not_ends_with_nocase: String
  tokenContract: Bytes
  tokenContract_not: Bytes
  tokenContract_gt: Bytes
  tokenContract_lt: Bytes
  tokenContract_gte: Bytes
  tokenContract_lte: Bytes
  tokenContract_in: [Bytes!]
  tokenContract_not_in: [Bytes!]
  tokenContract_contains: Bytes
  tokenContract_not_contains: Bytes
  tokenId: BigInt
  tokenId_not: BigInt
  tokenId_gt: BigInt
  tokenId_lt: BigInt
  tokenId_gte: BigInt
  tokenId_lte: BigInt
  tokenId_in: [BigInt!]
  tokenId_not_in: [BigInt!]
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  ownerInfo: String
  ownerInfo_not: String
  ownerInfo_gt: String
  ownerInfo_lt: String
  ownerInfo_gte: String
  ownerInfo_lte: String
  ownerInfo_in: [String!]
  ownerInfo_not_in: [String!]
  ownerInfo_contains: String
  ownerInfo_contains_nocase: String
  ownerInfo_not_contains: String
  ownerInfo_not_contains_nocase: String
  ownerInfo_starts_with: String
  ownerInfo_starts_with_nocase: String
  ownerInfo_not_starts_with: String
  ownerInfo_not_starts_with_nocase: String
  ownerInfo_ends_with: String
  ownerInfo_ends_with_nocase: String
  ownerInfo_not_ends_with: String
  ownerInfo_not_ends_with_nocase: String
  ownerInfo_: DAOTokenOwner_filter
  mintedAt: BigInt
  mintedAt_not: BigInt
  mintedAt_gt: BigInt
  mintedAt_lt: BigInt
  mintedAt_gte: BigInt
  mintedAt_lte: BigInt
  mintedAt_in: [BigInt!]
  mintedAt_not_in: [BigInt!]
  dao: String
  dao_not: String
  dao_gt: String
  dao_lt: String
  dao_gte: String
  dao_lte: String
  dao_in: [String!]
  dao_not_in: [String!]
  dao_contains: String
  dao_contains_nocase: String
  dao_not_contains: String
  dao_not_contains_nocase: String
  dao_starts_with: String
  dao_starts_with_nocase: String
  dao_not_starts_with: String
  dao_not_starts_with_nocase: String
  dao_ends_with: String
  dao_ends_with_nocase: String
  dao_not_ends_with: String
  dao_not_ends_with_nocase: String
  dao_: DAO_filter
  auction_: Auction_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  name
  image
  content
  tokenContract
  tokenId
  owner
  ownerInfo
  ownerInfo__id
  ownerInfo__owner
  ownerInfo__daoTokenCount
  mintedAt
  dao
  dao__id
  dao__name
  dao__symbol
  dao__totalSupply
  dao__description
  dao__contractImage
  dao__projectURI
  dao__tokenAddress
  dao__metadataAddress
  dao__auctionAddress
  dao__treasuryAddress
  dao__governorAddress
  dao__ownerCount
  dao__proposalCount
  dao__totalAuctionSales
  auction
  auction__id
  auction__startTime
  auction__endTime
  auction__extended
  auction__firstBidTime
  auction__settled
  auction__bidCount
}